---
title: "PMA Chapter 1 "
subtitle: "Summary"
date: 2019-12-21 20:39
background: '/img/posts/pma_1.jpg'
---

<!--<a href="https://www.freepik.com/free-photos-vectors/Background">Background vector created by freepik - www.freepik.com</a>-->


In this post we are going to discuss chapter 1 of [Practical Malware Analysis (PMA)](https://nostarch.com/malware)!
If you do not already own it I highly recommend it; as it is a fantastic resource for anyone interested in malware analysis, or reverse engineering!

**NOTE**: *PMA is focused on Windows executables. 
Due to that many of the concepts are on Window API concepts, however most of the high level ideas can be applied for any operating system.*

Chapter 1 of PMA is focused mainly on **basic static analysis** of binary files.
For binary analysis there are two forms of analysis **static** and **dynamic**; each have a basic and advanced form.
**Basic static analysis** is analysis that only looks at the metadata that can be retrieved from an executable.
Files are ***NOT*** run during this step!
Nor are they disassembled.

## Scanning and Hashing

A good first step is to see if the malware you are analyzing has been seen before.
This step can be done before looking at any metadata stored within an executable.
Looking online to see if a malware that you have already has been analyzed can be extremely helpful.
[Virus Total](https://www.virustotal.com/gui/home/upload) is a fantastic website that allows users to upload samples of files that they believe to be malicious.
However, be aware that posting malware samples online during an investigation can be counterproductive.
If the malware author becomes aware that someone is trying to analyze their malware they may try to change tactics...

Hashing is a common method to uniquely identify files and in particular malware.
A good hashing algorithm is a 1 to 1 function, that is, when data is sent into a hashing algorithm the output is unique to only that input data.
That means if I were send a file into SHA1 it's output should always be the same, and no other file should be able to reproduce the output of my file, unless they are the same files.

<!-- {% highlight bash %}
$ echo "hello" | shasum
f572d396fae9206628714fb2ce00f72e94f2258f  -
{% endhighlight %}

{% highlight bash %}
$ echo "Hello" | shasum
1d229271928d3f9e2bb0375bd6ce5db6c6d348d9  -
{% endhighlight %} -->

## Strings

Searching through strings, a sequence of characters, in a program is a easy way to get hints about a programs purpose.
For example, if you searched through the strings of a program and found a bunch of IP addresses and domain names one may assume the program has some sort of networking functionality.
If you were to find verbs like "sleep", "execute", "download" you may assume that the program takes commands from a server.

The **[strings](https://docs.microsoft.com/en-us/sysinternals/downloads/strings)** utility can be used to find both ASCII and UNICODE strings found inside a program.
However, it is not installed by default on Windows.

**NOTE**: *By default strings ignores "strings" less than 4 characters.*

An alternative tool to strings is [FLOSS](https://github.com/fireeye/flare-floss). 
FLOSS is made by FireEye Labs Advanced Reverse Engineering or FLARE.
Other than just pulling basic strings out of a binary it attempts to find obfuscated strings using advanced static analysis.

## Packed Binaries 

Malware writers want their malware to succeed and to do that they need to write malware that is difficult to analyze.
Therefore, most often than not successful malware is packed or obfuscated in some way.

Obfuscated programs are programs that have had their internals manipulated in a way to deter or confused malware analysts.
Like [movfuscator](https://github.com/xoreaxeaxeax/movfuscator), one of the most horrendous obfuscators out there... 

Packing malware is a way to compress a program and can be considered a subset of obfuscation.
Malware that has been packed use a small wrapper program to decompress the packed file. 
Therefore when looking at a packed file, most of the time you are looking at the unpacker not the actual malware.

[PEiD](https://www.aldeid.com/wiki/PEiD) is a fantastic tool to detect packed files.
PEiD is only as smart as the plugins you have along with it!
If PEiD does not have a plugin for the packer your malware has been compressed with it won't be able to identify it;
most malware writers build custom packers because of this.

## Portable Executable Format

When programs are compiled on Windows they generate a portable executable (PE).
PE files are used by executable, DLLs, and object code.
If you are on a Linux based system you will get an executable and linking format file (ELF), on Mac you have Mach Object file formats (Mach-O).

Each section of the PE file contains information that is required for the Windows OS to correctly load and run the file.

![PE Format](/img/posts/pe_format.jpg)

There are a multitude of programs out there to parse PE files and pull out important information.
[PEView](http://wjradburn.com/software/) is an older tool. It's very small and does not have as much bells as whistles as the other tools.
[CFF Explorer](https://ntcore.com/?page_id=388) is another PE parser. 
One of its benefits is that it contains a dependency walker for all the imported functions used by the binary.
The professional PE explorer ([PPEE](https://www.mzrst.com/) or puppy) is also a fantastic tool. 
It has all the benefits the CFF Explorer has but has support for plugins and tries to categorize the strings located in a binary.

<!-- <some *blue* text</span> -->


## Basic Static Analysis Programs

* [PEView](http://wjradburn.com/software/)
* [CFF Explorer](https://ntcore.com/?page_id=388)
* [PPEE](https://www.mzrst.com/)
* [Strings](https://docs.microsoft.com/en-us/sysinternals/downloads/strings)
* [FLOSS](https://github.com/fireeye/flare-floss)
* [PEiD](https://www.aldeid.com/wiki/PEiD) 

