# UMass CTF 2020 - Reversing

## Baby Crackme I

### Prompt

I haven't touched a computer since I retired. Can you help me decipher this program I wrote 30 years ago? ...

---

You should be able to solve this one, even if you've never written C before; it isn't essential to understand every single line. If you do want a quick (one page) reference on C, though, look [here](https://learnxinyminutes.com/docs/c/).

Created by @Jakob

### Hint

Strings in C are arrays of characters.


### TLDR;

The flag is declared in plaintext in the source file which is compared against the users input.
You can pull it out yourself you have bash do the heavy lifting for you.

`head -n 38 crackme.c | cut -d "=" -f 2 | cut -d ')' -f 1 | tail -n 32 | tr -d "\n\r' "`

### Flag

`UMASS{som3t1m3s_1t_1s_th1s_34sy}`

## Baby Crackme II


### Prompt

... back then, compilers weren't very good. I wrote this version, hoping it would be faster. Can you help me figure out what I chose for the "license key"? ...

---

You might need to understand a little bit more C for this one, but I believe in you!

Created by @Jakob

### Hint

Characters in C are just numbers. [This](https://man7.org/linux/man-pages/man7/ascii.7.html) is a useful mapping of numbers to letters.

### TLDR;

Assembly is inlined to compare each character of the users input against hard coded values.
This one is definitely a little more tedious to pull out by hand.

`for word in $(grep -i CMP crackme.c | cut -d ',' -f2 | tail -n +2|cut -d ')' -f1); do printf "\x$(printf %x $word)"; done;`

### Flag

`UMASS{v1r7u4l_m4ch1n35_4r3_c00l}`

## Baby Crackme III

### Prompt

... and I lost the source code to this one. But you've worked your magic for the past two, so I'm sure you can figure this one out?

---

Welcome to hard mode! You're going to have to learn to disassemble a binary.

Computers actually can't run C or Java without compiling it down to "machine code" first. "Assembly" is a set of phrases we associate with certain "instructions" in machine code so that we can read it.

There are plenty of disassemblers out there, but an easy way of spitting out the assembly code to the terminal is:

`objdump -D -Mintel crackme`

But you're going to have to do some digging on your own :)

Maybe try looking up "reverse engineering linux binary"?

Created by @Jakob

### Hint

Once you get the disassembly, this is very similar to Baby Crackme II.

### TLDR;

Loading the binary in IDA we see that it calls a `check_flag` function.
Inside of that function it works almost identically to the prior challenge.
We can use `gdb` to dump out the function and then the same script as before to get the flag!

`gdb -batch -ex 'file Desktop/crackme' -ex 'disassemble check_flag' | for word in $(grep -i CMP | cut -d ',' -f2 | tail -n +2|cut -d ')' -f1); do printf "\x$(printf %x $word)"; done;`

### Solution

```python
import os
import angr


PATH = os.path.join(os.path.dirname(__file__), "crackme")


def main():

    proj = angr.Project(PATH, auto_load_libs=False)
    simulation = proj.factory.simgr()

    constraint = lambda s: b"License key accepted" in s.posix.dumps(1)
    simulation.explore(find=constraint)
    if simulation.found:
        pprint(simulation.one_found)


def pprint(solutions):
    str_solutions = solutions.posix.dumps(0).replace(
        b'\x00', b'\n').decode('utf8', errors='ignore').strip().split('\n')

    for solution in str_solutions:
        print(f"Flag found: {solution}")


if __name__ == '__main__':
    main()
```

### Flag

`UMASS{now_you_c4n_put_4ss3mbly_on_your_r3sum3}`

## Linear Algebra

### Prompt

Meh. I never understood why they make the CS students take MATH 235.

---

You're going to have to disassemble this one, too. Sorry :)

Created by @Jakob

### Hint

I'd go about this by writing down the equalities that are being checked in terms of symbolic variables (i.e. α + β + γ = 277), figuring out where the equations overlap, and then using the math skills I learned in high school.

### TLDR;

Throw it at ANGR

```python
import os
import angr


PATH = os.path.join(os.path.dirname(__file__), "crackme")


def main():

    proj = angr.Project(PATH, auto_load_libs=False)
    simulation = proj.factory.simgr()

    constraint = lambda s: b"License key accepted" in s.posix.dumps(1)
    simulation.explore(find=constraint)
    if simulation.found:
        pprint(simulation.one_found)


def pprint(solutions):
    str_solutions = solutions.posix.dumps(0).replace(
        b'\x00', b'\n').decode('utf8', errors='ignore').strip().split('\n')

    for solution in str_solutions:
        print(f"Flag found: {solution}")


if __name__ == '__main__':
    main()
```

### Flag

`UMASS{c0mpu73r_5c13nc3_15_ju57_m47h}`

## Even/Odd

### Prompt

I made this program that generates the flag and writes it to the console. It's really fast!

---

Created by @Jakob

### Hint

It isn't "really fast". This is an "optimize me" challenge. There are a couple of ways to go about this, but the easier routes involve "binary patching". That's the keyword you should be looking for online.

### TLDR;

Patch the binary to calculate if an number is even / odd in a more optimized manner
At 0x00000000000011BD modify the next 8 bytes from

`0x48 0x8b 0x45 0xE8 0x48 0x89 0x45 0xF8 0xeb 0x1c` to
`0x48 0x89 0xF8 0x48 0x83 0xE0 0x01 0x90 0xeb 0x41`

```asm
mov rax, rdi
and rax, 1
nop
jmp short locret_1208
```

### Flag

`UMASS{w0w_y0ur3_p4713n7}`

## Marius

### Prompt

I wanted to do my 575 homework in LaTeX, so I asked him what he used for editing. He sent me this.

### TLDR;

The elisp script takes in a 30 long character string. Discards the first 6 characters and the last character.
It then swaps characters through out the string and compares the final manged string against a hardcoded one `1v_ms14__ks1rtpk_1dd13s`.

### Flag

`UMASS{v1m_1s_4_skr1pt_k1dd13s}`
